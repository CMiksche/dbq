// DO NOT MODIFY! AUTO GENERATED BY igo v1.0.1 (https://github.com/rocketlaunchr/igo)
// Copyright 2019 PJ Engineering and Business Solutions Pty. Ltd. All rights reserved.

package dbq

import fordefer "github.com/rocketlaunchr/igo/stack"

import (
	"fmt"
	"reflect"
	"strings"
	"time"

	"github.com/mitchellh/mapstructure"
)

// Database is used to set the Database.
// Different databases have different syntax for placeholders etc.
type Database int

const (
	// MySQL database
	MySQL Database = 0
	// PostgreSQL database
	PostgreSQL Database = 1
)

// INSERT will generate an INSERT statement.
func INSERT(tableName string, columns []string, rows int, dbtype ...Database) string {
	return fmt.Sprintf("INSERT INTO %s ( %s ) VALUES %s", tableName, strings.Join(columns, ","), Ph(len(columns), rows, 0, dbtype...))
}

// Ph generates the placeholders for SQL queries.
// For a bulk insert operation, rows is the number of rows you intend
// to insert, and columnsN is the number of fields per row.
// For the IN function, set rows to 1.
// For PostgreSQL, you can use incr to increment to placeholder starting count.
func Ph(columnsN, rows int, incr int, dbtype ...Database) string {

	var typ Database
	if len(dbtype) > 0 {
		typ = dbtype[0]
	}

	if typ == MySQL {
		inner := "( " + strings.TrimSuffix(strings.Repeat("?,", columnsN), ",") + " ),"
		return strings.TrimSuffix(strings.Repeat(inner, rows), ",")
	}

	var singleValuesStr string

	varCount := 1 + incr
	LCtTMtTCoaNatyy := fordefer.NewStack(true)
	defer LCtTMtTCoaNatyy.Unwind()
	for i := 1; i <= rows; i++ {
		singleValuesStr = singleValuesStr + "("
		iNKAReKJyiXJrsc := fordefer.NewStack(true)
		defer iNKAReKJyiXJrsc.Unwind()
		for j := 1; j <= columnsN; j++ {
			singleValuesStr = singleValuesStr + fmt.Sprintf("$%d,", varCount)
			varCount++
			iNKAReKJyiXJrsc.Unwind()
		}
		singleValuesStr = strings.TrimSuffix(singleValuesStr, ",") + "),"
		LCtTMtTCoaNatyy.Unwind()
	}

	return strings.TrimSuffix(singleValuesStr, ",")
}

func sliceConv(arg reflect.Value) []interface{} {
	out := []interface{}{}

	if arg.Kind() == reflect.Slice {
		ctNswYNsGRussVm := fordefer.NewStack(true)
		defer ctNswYNsGRussVm.Unwind()
		for i := 0; i < arg.Len(); i++ {
			out = append(out, sliceConv(reflect.ValueOf(arg.Index(i).Interface()))...)
			ctNswYNsGRussVm.Unwind()
		}
	} else {
		out = append(out, arg.Interface())
	}

	return out
}

// StdTimeConversionConfig provides a standard configuration for unmarshaling
// to a struct. It properly converts timestamps and datetime columns into
// time.Time objects. It assumes a MySQL database as default.
func StdTimeConversionConfig(dbtype ...Database) *StructorConfig {

	layout := "2006-01-02 15:04:05"
	if len(dbtype) > 0 && dbtype[0] == PostgreSQL {
		layout = time.RFC3339
	}

	return &StructorConfig{
		DecodeHook:       mapstructure.StringToTimeHookFunc(layout),
		WeaklyTypedInput: true,
	}
}
